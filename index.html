<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Thesis by xcodevn</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      
    <div class="wrapper">

      <section>
<h1 class="wmd-title" id="interactive-verification-and-speed-up-techniques">INTERACTIVE VERIFICATION AND SPEED UP TECHNIQUES</h1>

<p>Tầm nhìn ta thật ngắn mà đã thấy bao thứ phải làm – Alan Turing</p>

<h2 class="wmd-title" id="abstract">Abstract</h2>

<blockquote>
  <p>Beware of bugs in the above code; I have only proved it correct, not tried it – Donald Knuth</p>
  
  <p>Cẩn thận với lỗi trong đoạn mã trên; tôi chỉ mới chứng minh nó đúng, chứ chưa hề chạy thử nó – Donald Knuth</p>
</blockquote>

<p>Chứng minh tính đúng đắn của một chương trình may tinh dùng formal methods <a href="#fn:formalmethods" id="fnref:formalmethods" title="See footnote" class="footnote">1</a> mang lại sự đảm bảo cao nhất cho các chương trình yêu cầu tính chính xác cao (ví dụ chương trình lái tàu vũ trụ, lái máy bay, lái tàu điện ngầm, …) Đây hoàn toàn không phải là công việc dễ dàng, hiện nay chương trình máy tính vẫn chưa thể tự động hoàn toàn trong việc chứng minh các chương trình phức tạp trong thực tế [cite-source]. Một hệ quả là phải có sự tương tác giữa người với máy tính trong quá trình chứng minh các đoạn mã phức tạp.</p>

<p>Luận văn này hiện thực ý tưởng về <em>interactive verification</em>, là sự tương tác
giữa người và chương trình chứng minh nhằm chứng minh tính đúng đắn của các
chương trình phức tạp.</p>

<blockquote>
  <p>Với việc sử dụng <em>rewriting term</em>, hệ thống Leon [footnote] đã có thể tạo ra &gt; sự tương tác hai chiều với người dùng. [Remove]</p>
</blockquote>

<p>Bên cạnh đó, luận văn còn đề cập tới khía cạnh tốc độ của quá trình chứng minh, 
một loạt các kỹ thuật tăng tốc đã được áp dụng nhằm cải tiến tốc độ của hệ thống. Có thể kể đến ba nổ lực chính: 
(1) áp dụng bộ lọc sử dụng tri thức của hệ thống và học máy để lọc bỏ những
phần thừa trong quá trình tính toán, 
(2) kĩ thuật profiling được áp dụng nhằm phát hiện những mắc xích chiếm lượng
lớn thời gian tính toán, từ đó mà tập trung cải thiện tốc độ của các phần này,
(3) thực hiện song song hóa quá trình chứng minh.</p>

<p>Dựa vào những kĩ thuật trên, luận văn đã đạt được một sự cải thiện rõ rệt về tốc
độ của hệ thống, tốc độ chứng minh đã tăng xấp xĩ <strong>30 lần</strong> so với bản hiện
thực ban đầu.</p>

<p>Bên cạnh những kết quả đạt được trên, bản thân tác giả cũng gặt hái được nhiều
kinh nghiệm quý báu trong quá trình làm luận văn, nhất là kinh nghiệm trong quy
trình hiện thực hệ thống và trong việc đảm bảo chất lượng, tính ổn định của hệ
thống. Thiết nghĩ đây là những kinh nghiệm quan trọng đối với một người kĩ sư.</p>

<hr>

<h2 class="wmd-title" id="acknowledgement">Acknowledgement</h2>

<p>Tác giả gửi lời cảm ơn chân thành đến phó giáo sư tiến sĩ Quản Thành Thơ, phó
giáo sư tiến sĩ Viktor Kuncak đã có những góp ý quan trọng và định hướng cho
luận văn này.</p>

<p>Tác giả gửi lời cảm ơn của mình đến anh Hoàng Lê Nghĩa Đức, là người đã theo
sát, và hỗ trợ tác giả trong thời gian làm luận văn.</p>

<p>Và trên tất cả, luận văn này dành cho gia đình của tác giả, nhất là người mẹ đã luôn
chăm sóc và dõi theo tác giả.</p>

<p>Gửi lời tưởng nhớ đến thầy Dương Công Vinh, người đã dắt tác giả đi những bước đi đầu tiên trên con đường đến với ngành <em>khoa học máy tính</em>.</p>

<hr>

<h2 class="wmd-title" id="đóng-góp-của-luận-văn">Đóng góp của luận văn</h2>

<p>Luận văn đã mở rộng khả năng của hệ thống hiện tại, cho phép hỗ trợ
chứng minh tương tác, sử dụng các bổ để, từ đó cho phép chứng minh tự động
những tính chất mà trước kia phải dựa vào người sử dụng.</p>

<p>Luận văn cũng nên lên ý tưởng về <em>interactive learning</em>, trong đó cho phép giải
thuật học máy có thể học từ chính quá trình sử dụng hệ thống của người dùng.</p>

<p>Với những nổ lực trong việc cải thiện tốc độ, hệ thống đã có những cải
thiện rõ rệt về tốc độ, góp phần cải thiện đáng kể thời gian tương tác với người dùng. [lủng củng]</p>

<p>Việc sử dụng bộ lọc áp dụng học máy không chỉ có tác dụng tăng tốc cho riêng hệ
thống, mà bộ lọc còn có thể được sử dụng trong các trường hợp tương tự, có thể kể đến như là bộ lọc đảm nhận vai trò tiền xữ lý trong đề tài "Name it please" của nghiên cứu sinh [Tên anh í]</p>

<p>Một đóng góp nhỏ và thuần túy về kỹ thuật, trong thời gian làm việc với hệ thống, tác giả đã phát hiện và sửa được một lỗi tồn tại trong một thời gian dài bên trong nhân của hệ thống.</p>

<p>Bên cạnh đó, trong thời gian rãnh rỗi của mình, tác giả cũng đã thiết kế một
giao diện mới cho hệ thống trên nền web. Tuy khối lượng công việc nhỏ, nhưng cũng có thể coi đây là một thói quen có ích trong việc sử dụng thời gian rãnh rỗi.</p>

<hr>

<h2 class="wmd-title" id="table-of-contain">Table of contain</h2>

<h2 class="wmd-title" id="introduction">Introduction</h2>

<p>Logic học là lĩnh vực nghiên cứu về sự suy luận đúng đắn. Ngày nay, logic học là nền tảng của mọi lĩnh vực toán học hiện đại. Logic được nhiều nhà hiền triết nghiên cứu từ thời cổ đại, có thể kể đến logic tam đoạn luận [footnote] của Aristote. Logic học thực sự trở thành nền tảng của toán học từ cuối thế kỉ XIX đầu thế kỉ XX với nổ lực thống nhất toán học trên cùng một nền tảng logic học của Hilbert, được biết đến với tên gọi <em>chương trình Hilbert</em>. Để rồi đến năm 1931 khi  Kurt Gödel đập tan chương trình Hilbert với việc chứng minh hai định lý <em>bất hoàn chỉnh</em> [lúa quá] nổi tiếng [cite-footnote]<a href="#fn:hg" id="fnref:hg" title="See footnote" class="footnote">2</a>. Tất nhiên chương trình Hilbert không phải là vô dụng, bộ mặt của toán học đã thay đổi hoàn toàn, logic giờ đã đóng vai trò là nền tảng trong mọi nhánh của toán học. Đưới nền tảng logic vững chắc, mọi định lý toán học sẽ luôn là những chân lý trường tồn cùng thời gian.</p>

<p>Năm 1969, Dana S. SCoot<a href="#fn:dana" id="fnref:dana" title="See footnote" class="footnote">3</a> viết một bài báo đánh dấu sự ra đời của <em>Logic cho những hàm khả tính</em> (Logic of Computable Functions - LCF). Bài báo này mở ra một nhánh nghiên cứu mới, là sự kết hợp giữa logic học và giải tích lambda. Trên nền tảng đó, các nhà nghiên cứu tại đại học Edinburgh dưới sự dẫn dắt của Robin Milner [footnote: Robin Milner đạt giải Turing năm 1991 cho những đóng góp với ngành Khoa học máy tính] LCF, một trong những <em>interactive automated theorem prover</em> đầu tiên. Bên cạnh đó là sự ra đời của ngôn ngữ lập trình hàm ML, ngon ngu này anh hưởng lớn tới các ngôn ngữ lập trình hàm hiện đại như Ocamal, Haskell, hay Scala.</p>

<p>Điều thú vụ của lịch sử là bài báo này chưa từng được công bố rộng rãi cho đến tận năm 1993, lý do cho việc này là tác giả của bài báo nhận thấy sự không cần thiết của việc xuất bản bài báo :)
Có lẽ đây là bài báo không được xuất bản có ảnh hưởng lớn nhất trong lịch sử của ngành Khoa học máy tính.</p>

<p>Những <em>proof asisstance</em><a href="#fn:proofasiss" id="fnref:proofasiss" title="See footnote" class="footnote">4</a> có thể chứng minh (dựa trên tương tác với người dùng) những định lý lớn của toán học, có thể kể đến định lý bất hoàn hảo của Godel, định lý Fermat lớn[^fermat].</p>

<p>Bên cạnh đó là những ứng dụng thực tiễn, có thể kể đến hardware verification[cite], chứng minh tính đúng đắn của một hệ điều hành hoàn chỉnh [cite L4OS], trình biên dịch [cite], JavaCard[cite]</p>

<p>Leon là một chương trình chứng minh tự động được phát triển bởi nhóm nghiên cứu
LARA tại đại học EPFL, Thụy Sĩ.
Điểm mạnh của Leon là cho phép người lập trình dùng chính ngôn ngữ Scala cho
việc đặc tả những tính chất của chương trình Scala.
Leon có thể phát hiện ra các <em>phản ví dụ</em> trong trường hợp có sự sai khác giữa đặc tả và hiện thực.</p>

<p>Về nguyên tắc, Leon thực hiện việc chứng minh trên môt ngôn ngữ gọi là PureScala.
Ngôn ngữ này là một tập con của ngôn ngữ Scala, chỉ hỗ trợ các hàm không có hiệu ứng lề (thuần hàm) với yêu cầu các hàm này phải là hàm bậc nhất (không nhận một hàm khác như là tham số, cũng như không trả về một hàm) và chỉ hỗ trợ các kiểu dữ liệu đơn giản (số nguyên, kiểu dữ liệu trừu tượng, tập hợp, tuples)</p>

<p>Leon hoạt động dựa trên ý tưởng đơn giản là <em>unrolling</em>. Để chứng minh một
biểu thức thỏa một tính chất nào đó, với những hàm không đệ quy trong biểu thức, ta có thể thực hiện đơn giản bởi việc thay lời gọi hàm bằng thân của hàm này đã được thay các biến bởi các tham số truyền theo. 
Đối với các hàm gọi chính nó (hàm đệ quy) Leon cũng thực hiện tương tự, nhưng
kết quả cho mỗi lần <em>unrolling</em>, ta chỉ được một phiên bản xấp xỉ với hàm đệ qui.
Dựa vào việc <em>xấp xĩ dưới</em> (một xấp xĩ mà nếu hàm này trả về là sai với đặc tả
thì hàm đệ quy cũng sai với đặc tả), và <em>xấp xĩ trên</em> (một xấp xĩ mà nếu hàm
này trả về là đúng với đặc tả thì hàm đệ quy cũng đúng với đặc tả) ta có thể
thoát ra khỏi quá trình Unrolling vô tận và vẫn đảm bảo tính đúng đắn của chứng
minh (hoặc phản ví dụ). 
Nói một cách ngắn gọn , de chứng minh một tính chất của một biểu thức ta thực
hiện chứng minh trên các xấp xĩ trên và xấp xĩ dưới của biểu thức này.</p>

<p>Tuy nhiên, hệ thống Leon hiện tại hỗ trợ kém trong việc chứng minh một tính
chất của chương trình bằng cách sử dụng các bổ đề kèm theo.
Một sự thật rằng đa phần các chứng minh luôn cần những bồ đề kèm theo. 
Có thể giải thích duoc việc này nếu coi Leon là một hệ thống chứng minh diễn dịch, nói cách khác, thông thường Leon sẽ không thể thực hiện việc chứng minh qui nạp nếu không có sử tương tác với người dùng.
Chính các bổ đề sẽ lấp đầy mắc xích trống, các bổ đề sẽ nhận nhiệm vụ chứng minh qui nạp.</p>

<p>Luận văn đưa ra ý tưởng sử dụng rewriting term, để don gian hoa biểu thức cần
chứng minh trước khi đưa cho solver bên dưới.</p>

<p>Quá trình <em>simplify</em> một biểu thức là quá trình biển đổi biểu thức về một dạng
tương tương nhưng đơn giản hơn thong qua cac <em>rewriting rules</em>.
Bằng việc sử dụng các <em>rewriting rules</em> có dạng <code>COND ==&gt; LHS = RHS</code> ta có
thể thay vế trái <code>LHS</code> bằng vế phải <code>RHS</code> nếu <code>COND</code> được thỏa.
Quá trình xem ra đơn giản này là một trong những cấu thành chính va phuc tap
nhat của các <em>Interactive proof assistance.</em></p>

<p>Bằng việc chuyển đổi các bổ đề, định nghĩa hàm, giả thuyết quy nạp trở thành các <em>rewriting rules</em> ta có thể chứng minh một cách tự động những tính chất mà trước kia phải làm bằng tay.</p>

<p>Một trong những chú trọng của luận văn này là cải thiện thời gian chứng minh của Leon tới mới tối đa có thể. Có thể kể đến ba nỗ lực chính để đạt mục tiêu trên.</p>

<p>Thứ nhất là việc sử dụng một bộ lọc nhằm lọc ra các <em>rewrite rules</em> không cần
thiết cho quá trình chứng minh.
Thực nghiệm cho thấy một số lượng ít các rules là cần thiết cho quá trình
chứng minh.
Để cải thiện tốc độ ta mong muốn lọc ra nhưng rules cần thiết và loại bỏ những
rules thừa.
Tất nhiên là hiệu năng mang lại phải lớn hơn phí tổn trong khi bộ lọc hoạt động.
Bằng việc sử dụng thuật toán học máy Naive-Bayes, luận văn này hiện thực một bộ
lọc có khả năng học được những tri thức từ quá trình chứng minh trước đó, hoặc
những tri thức do người dùng đưa vào để cải thiện chất lượng của bộ lọc.</p>

<p>Thứ hai là việc sử dụng kĩ thuật profiling, đây là một quy trình kép kín,
profiling cho phép phát hiện những bộ phận trong hệ thống chiếm phần lớn tài
nguyên máy tính (CPU hay RAM) từ đó chúng ta tập trung cải tiến những phần quan
trọng này.
Quy trình này được lập lại, và mỗi lần lặp tốc độ của hệ thống lại được cải thiện.</p>

<p>Nỗ lực thứ ba để đẩy tốc độ của hệ thống và có lẽ là nhân tố quan trọng nhất đó
là thực hiện song song hóa hệ thống hiện tại.
Ý tưởng đơn giản là ta có thể chứng minh các tính chất của chương trình một cách song song, độc lập với nhau.
Chỉ với nỗ lực này, kết quả đạt được là hệ thống có thể mở rộng tới mức tối đa.</p>

<p>Ở phần cuối của luận văn, tác giả cũng đề cập tới qui trình hiện thực toàn bộ
luận văn sử dụng công cụ quản lý dự án Github cũng như git cho chức năng quản lý mã nguồn, mà theo ý kiến riêng của tác giả là điều này nằm ngoài những kiến thức đã được dạy ở giảng đường.
Bên cạnh đó là kinh nghiệm của tác giả trong việc đảm bảo chất lượng cũng như
tính ổn định của hệ thống thông qua việc thực hiện <em>regression testing</em> và <em>tích hợp liên tục</em> (CI - english please!)</p>

<p>Phần tiếp theo sẽ đi vào chi tiết về interactive verification, các kĩ thuật tăng tốc được áp dụng.</p>

<h2 class="wmd-title" id="interactive-verification">Interactive verification</h2>

<p>Như đã lập luận ở trên, quá trình chứng minh những chương trình phức tạp là quá trình tương tác giữa người sử dụng và chương tình máy tính. Ở đây ta sẽ mô tả một kịch bản cho quá trình tương tác này.</p>

<h3 class="wmd-title" id="kịch-bản">Kịch bản</h3>

<p>Câu chuyện bắt đầu khi nhân vật chính của chúng ta, Văn Hòa, muốn chứng minh tính đúng đắn của thuật toán sắp xếp mới do chính tay Văn Hòa nghĩ ra. Văn Hòa bắt đầu mô tả tính chất mong muốn của thuật toán, đầu vào theo như hắn nghĩ chắc chắn sẽ là một danh sách các số nguyên, và đầu ra của thuật toán sẽ là một hoán vị của danh sách ban đầu sao cho các số nguyên trong danh sách có thứ tự không giảm.</p>

<p>Vậy là Văn Hòa đã đặc tả được tính chất mong muốn cho thuật toán của mình, một thuật toán sắp xếp tăng dần. Nhân vật chính hứng thú nhấp chuột vào nút <em>Chứng minh</em> trên cửa sổ phần mềm vô danh [Microsoft Word ;)]. Một lát sau, có lẽ là 10 phút sau, phần mềm trả về một thông báo không hề được mong đợi “Không thể chứng minh.” Chỉ vỏn vẹn một thông báo như vậy. </p>

<p>Văn Hòa bắt đầu trâm ngâm suy nghĩ ”ừ thì đồng ý là chương trình này phức tạp nên không thể chứng minh được nhưng …” Nhân vật chính ”Ồ!” lên trong khoảng không, dường như anh đã nhận ra một điều gì đó tinh tế. Thầm nghĩ trong đầu “nếu không thế chứng minh được thì ít nhất cũng phải chứng minh tới đâu đó, cho dù chưa tới đích.”</p>

<p>Tiếp tục với những suy tư trong đầu mình, cuối cùng bước tranh cũng dần hiện rõ trong đầu Văn Hòa. “Phải chăng có một cơ chế nào đó, biến mục tiêu cần chứng minh ban đầu, thành các mục tiêu con đơn giản hơn, lúc này người dùng có thể tập trung vào việc chứng minh các mục tiêu con.”</p>

<p>Màn đêm bắt đầu buông xuống, xung quanh phố phường chìm dần vào trong đêm tối, chỉ có căn phòng của nhân vật chính là con sáng điện. Trong căn phòng đó có một người đang miệt mài với những suy nghĩ trong đầu mình.</p>

<p>Những suy tư tưởng chừng như chỉ xuất hiện trong đầu Văn Hòa, nhân vật chính của chúng ta, cũng chính là suy tư của những người đã viết nên các <em>interactive ATP</em> nổi tiếng như LCF, HOL, Isabelle. <em>Cơ chế nào đó</em> trong câu chuyện là <em>proof tactic</em>, chiến lược chứng minh.</p>

<p>Một chiến lược chứng minh có thể được xem như một cổ máy có đầu vào là mục tiêu cần chứng minh, đầu ra của cổ máy này chính là một danh sách các mục tiêu con, tất nhiên là đơn giản hơn mục tiêu ban đầu.</p>

<p>Có thể kể đến hai chiến lược dễ hình dung và hữu hiệu:</p>

<ul>
<li><p>Chiến lược quy nạp: chiến lược này biến mục tiêu cần chứng minh thành hai mục tiêu con, mục tiêu thứ nhất chứng minh trường hợp cơ bản của quá trình quy nạp, mục tiêu con thứ hai là chứng minh trường hợp quy nạp.</p></li>
<li><p>Chiến lược đơn giản hóa (simplify): chiến lược này tìm cách biến đổi mục tiêu ban đầu (gọi là <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-4-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-20" style="width: 1.247em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.923em; height: 0px; font-size: 132%;"><span style="position: absolute; clip: rect(1.572em 1000.003em 2.492em -0.43em); top: -2.162em; left: 0.003em;"><span class="mrow" id="MathJax-Span-21"><span class="msubsup" id="MathJax-Span-22"><span style="display: inline-block; position: relative; width: 0.869em; height: 0px;"><span style="position: absolute; clip: rect(1.951em 1000.003em 2.708em -0.43em); top: -2.541em; left: 0.003em;"><span class="mi" id="MathJax-Span-23" style="font-family: MathJax_Math; font-style: italic;">e</span><span style="display: inline-block; width: 0px; height: 2.546em;"></span></span><span style="position: absolute; top: -2.162em; left: 0.436em;"><span class="mn" id="MathJax-Span-24" style="font-size: 70.7%; font-family: MathJax_Main;">1</span><span style="display: inline-block; width: 0px; height: 2.33em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.167em;"></span></span></span><span style="border-left-width: 0.004em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.932em; vertical-align: -0.282em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-4">e_1</script>) trở thành mục tiêu mới (gọi là <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-5-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-25" style="width: 1.247em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.923em; height: 0px; font-size: 132%;"><span style="position: absolute; clip: rect(1.572em 1000.003em 2.492em -0.43em); top: -2.162em; left: 0.003em;"><span class="mrow" id="MathJax-Span-26"><span class="msubsup" id="MathJax-Span-27"><span style="display: inline-block; position: relative; width: 0.869em; height: 0px;"><span style="position: absolute; clip: rect(1.951em 1000.003em 2.708em -0.43em); top: -2.541em; left: 0.003em;"><span class="mi" id="MathJax-Span-28" style="font-family: MathJax_Math; font-style: italic;">e</span><span style="display: inline-block; width: 0px; height: 2.546em;"></span></span><span style="position: absolute; top: -2.162em; left: 0.436em;"><span class="mn" id="MathJax-Span-29" style="font-size: 70.7%; font-family: MathJax_Main;">2</span><span style="display: inline-block; width: 0px; height: 2.33em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.167em;"></span></span></span><span style="border-left-width: 0.004em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.932em; vertical-align: -0.282em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-5">e_2</script>), tương tương với mục tiêu ban đầu. Rõ ràng ta có phương trình <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-6-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-30" style="width: 4.115em; display: inline-block;"><span style="display: inline-block; position: relative; width: 3.087em; height: 0px; font-size: 132%;"><span style="position: absolute; clip: rect(2.167em 1000.003em 3.087em -0.43em); top: -2.757em; left: 0.003em;"><span class="mrow" id="MathJax-Span-31"><span class="msubsup" id="MathJax-Span-32"><span style="display: inline-block; position: relative; width: 0.869em; height: 0px;"><span style="position: absolute; clip: rect(1.951em 1000.003em 2.708em -0.43em); top: -2.541em; left: 0.003em;"><span class="mi" id="MathJax-Span-33" style="font-family: MathJax_Math; font-style: italic;">e</span><span style="display: inline-block; width: 0px; height: 2.546em;"></span></span><span style="position: absolute; top: -2.162em; left: 0.436em;"><span class="mn" id="MathJax-Span-34" style="font-size: 70.7%; font-family: MathJax_Main;">1</span><span style="display: inline-block; width: 0px; height: 2.33em;"></span></span></span></span><span class="mo" id="MathJax-Span-35" style="font-family: MathJax_Main; padding-left: 0.273em;">=</span><span class="msubsup" id="MathJax-Span-36" style="padding-left: 0.273em;"><span style="display: inline-block; position: relative; width: 0.869em; height: 0px;"><span style="position: absolute; clip: rect(1.951em 1000.003em 2.708em -0.43em); top: -2.541em; left: 0.003em;"><span class="mi" id="MathJax-Span-37" style="font-family: MathJax_Math; font-style: italic;">e</span><span style="display: inline-block; width: 0px; height: 2.546em;"></span></span><span style="position: absolute; top: -2.162em; left: 0.436em;"><span class="mn" id="MathJax-Span-38" style="font-size: 70.7%; font-family: MathJax_Main;">2</span><span style="display: inline-block; width: 0px; height: 2.33em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.762em;"></span></span></span><span style="border-left-width: 0.004em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.932em; vertical-align: -0.282em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-6">e_1 = e_2</script>. Một cách tổng quát hóa, quá trình đơn giản hóa là quá trình áp dụng các luật có dạng 
<code>COND ==&gt; LHS = RHS</code>, tức là nếu điều kiện <code>COND</code> được thỏa thì ta sẽ thay thế biểu thức <code>LHS</code> bằng biểu thức <code>RHS</code>.</p></li>
</ul>

<p>Trong phần tiếp theo, ta sẽ đi vào chi tiết của chiến lược đơn giản hóa. Đây là cấu thành quan trọng nhất đối với <em>interactive verification.</em></p>

<h3 class="wmd-title" id="simplification">Simplification</h3>

<h3 class="wmd-title" id="rewrite-rules">Rewrite rules</h3>

<p>Như vừa trình bày ở phần trên, ta đã có có được cỗ máy thực hiện quá trình đơn giản hóa, tuy nhiên ta vẫn còn thiếu nguyên liệu cho cỗ máy này hoạt động, chính là các <em>rewrite rules</em>. Các rules có thể được lấy từ những nguồn sau:</p>

<h4 class="wmd-title" id="các-tiên-đề">Các tiên đề</h4>

<p>Có thể ví dụ các tiên đề số học sau:</p>

<p>x + 0 = x
   0 + x = x <br>
   1 * x = x
   x * 1 = x</p>

<p>Nhiều tiên đề khác có thể trở thành các rewrite rules.</p>

<h4 class="wmd-title" id="các-định-nghĩa-hàm">Các định nghĩa hàm</h4>

<p>Một hàm số không đệ qui là một trường hợp tốt để trở thành rewrite rules. Chẳng hạn</p>

<pre class="prettyprint prettyprinted" style=""><code><span class="kwd">def</span><span class="pln"> sum</span><span class="pun">(</span><span class="pln">a</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">,</span><span class="pln"> b</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">require</span><span class="pun">(</span><span class="pln">a </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln">
  a </span><span class="pun">+</span><span class="pln"> b
</span><span class="pun">}</span></code></pre>

<p>Trong trường hợp này ta có thể có rule sau <code>a &gt; 0 ==&gt; sum(a, b) = a + b</code></p>

<p>Một hàm đệ qui cũng có thể trở thành các rewrite rules.</p>

<pre class="prettyprint prettyprinted" style=""><code><span class="kwd">def</span><span class="pln"> factorial </span><span class="pun">(</span><span class="pln">n</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> n match </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">case</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
  </span><span class="kwd">case</span><span class="pln"> _ </span><span class="pun">=&gt;</span><span class="pln"> n </span><span class="pun">*</span><span class="pln"> factorial</span><span class="pun">(</span><span class="pln">n</span><span class="pun">-</span><span class="lit">1</span><span class="pun">)</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>Ta sẽ có được hai rewrite rules:
  - <code>n = 0 ==&gt; factorial(n) = 1</code>
  - <code>n != 0 ==&gt; factorial(n) = n * factorial(n-1)</code></p>

<h4 class="wmd-title" id="các-hàm-được-đánh-dấu-trở-thành-rewrite-rule">Các hàm được đánh dấu trở thành rewrite rule</h4>

<p>Đây là một trong những nguồn quan trọng để tạo ra các rewrite rule, chính là từ các định lý, trong trường hợp của chúng ta là các tính chất đã được chứng minh của một hàm nào đó.</p>

<pre class="prettyprint prettyprinted" style=""><code><span class="lit">@simp</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> append_nil_lemma</span><span class="pun">(</span><span class="pln">l</span><span class="pun">:</span><span class="pln"> </span><span class="typ">List</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
   append</span><span class="pun">(</span><span class="pln">l</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Nil</span><span class="pun">())</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> l
</span><span class="pun">}</span><span class="pln"> holds</span></code></pre>

<p>Hàm trên mô ta một hàm số mô tả một định lý rằng mọi danh sách khi nối liền với một danh sách rỗng thì luôn trả về chính danh sách ban đầu.</p>

<p>Annotation <code>@simp</code> thông báo cho chúng ta biết rằng hàm này sẽ được dùng như một rewrite rule. Ở đây ta sẽ có rule <code>append(l, Nil()) = l</code></p>

<h4 class="wmd-title" id="giả-thuyết-quy-nạp">Giả thuyết quy nạp</h4>

<p>Một khi ta dùng chiến lược quy nạp để chứng minh một tính chất, ta sẽ được trả về hai mục tiêu con, tương ứng với bước cơ sở và bước qui nạp.</p>

<p>Mục tiêu ở bước quy nạp sẽ có dạng <code>A ==&gt; B</code>. Với <code>A</code> là <em>giả thuyết quy nạp</em>.</p>

<p>Có thể nhận thấy trong khi chứng minh B, có có thể giả định là A đúng, và trong trường hợp A có dạng <code>LHS = RHS</code> hay nói cách khác là A có dạng của một rewrite rule, ta có thể dùng A như là một rewrite rule.</p>

<h4 class="wmd-title" id="giả-thuyết-cục-bộ-local-assumption">Giả thuyết cục bộ (Local assumption)</h4>

<p>[PHẦN NÀY PHỨC TẠP] [TRÌNH BÀY SAU]</p>

<h3 class="wmd-title" id="quá-trình-chứng-minh-tương-tác">Quá trình chứng minh tương tác</h3>

<p>[Có hình vẽ sẽ tốt hơn]</p>

<p>Có thể mô tả quá trình tương tác giữa người dùng và hệ thống như sau:</p>

<p>Bước 1: Người dùng mô tả tính chất cần chứng minh, giả định biểu thức cần chứng minh là <code>expr</code>. Đi tới bước 2</p>

<p>Bước 2: Hệ thống thực hiện đơn giản hóa <code>expr</code>. <code>val simple_expr = simplify(expr)</code> Sau đó cố gắng chứng minh <code>simple_expr</code>: <code>val result = proof(simple_expr)</code></p>

<ul>
<li>Bước 2a, <code>result = VALID</code>, hệ thống trả về chứng minh thành công. Kết thúc.</li>
<li>Bước 2b, <code>result = INVALID</code>, hệ thống trả về phản ví dụ chứng minh rằng hiện thực sai khác so với đặc tả. Kết thúc.</li>
<li>Bước 2c, <code>result = UNKNOWN</code>,  hệ thống thông báo <code>simple_expr</code> cho người dùng. Đi tới bước 3.</li>
</ul>

<p>Bước 3: Người dùng mô tả thêm các hàm đóng vai trò là bổ đề cho việc chứng minh <code>simple_expr</code>. Quay lại bước 2.</p>

<p>Quá trình tương tác này kết thúc chỉ khi tính chất được chứng minh là đúng, hoặc phản ví dụ chứng tỏ bản hiện thực sai so với đặc tả.</p>

<h2 class="wmd-title" id="advanced-speedup-techniques">Advanced speedup techniques</h2>

<h3 class="wmd-title" id="machine-learning-filter">Machine learning filter</h3>

<p>Ý tưởng đơn giản với mục đích tăng tốc quá trình đơn giản hóa biểu thức là xây dựng một bộ lọc nhằm lọc ra những rules không cần thiết cho quá trình đơn giản hóa này.</p>

<p>Ý tưởng này dựa trên một quan sát nhận thấy tuy số lượng các rewrite rules là lớn, nhưng quá trình đơn giản hóa một biểu thức bất kì lại chỉ sử dụng một số ít các rules này. Điều này dẫn tới nếu chúng ta có thể lọc đi đa số các rules thừa, tốc độ sẽ được cải thiện đáng kể.</p>

<p>Ở bài báo [x cite] [y cite] [z cite] các tác giả đề xuất ý tưởng sử dụng các thuật toán học máy để cải thiện bộ lọc. Áp dụng ý tưởng trong trường hợp của chúng ta, thuật toán học máy có thể được sử dụng để <em>học</em> được mối liên hệ giữa một biểu thức với với các rules cần thiết để đơn giản hóa nó. Dữ liệu được dùng để học có thể bắt nguồn từ tri thức do người dùng cung cấp hoặc từ chính các quá trình simplify trước đó.</p>

<p>Bản hiện thực bộ lọc trong luận văn này chịu ảnh hưởng lớn từ bài báo [x cite], nguyên gốc bài báo xây dựng bộ lọc cho interactive ATP Isabellel. </p>

<p>Ở phần tiếp theo, chúng ta đi vào chi tiết bộ lọc với hiện thực là thuật toán học máy Naive-Bayes [footnote]</p>

<h4 class="wmd-title" id="naive-bayes-filter">Naive-Bayes filter</h4>

<h4 class="wmd-title" id="sai-lầm-trong-hiện-thực">Sai lầm trong hiện thực</h4>

<p>Phiên bản hiện thực ban đầu của bộ lọc thực chất là tái sử dụng lại bộ lọc được sử dụng trong bài báo [x cite]. Bộ lọc này có tên là MaSh, viết tắt của MAchine learning for SledH…. [footnote]</p>

<p>MaSh được hiện thực như một chương trình viết bằng ngôn ngữ Python. Hệ thống sẽ tương tác với MaSh bằng cách viết dữ liệu đầu vào lên một tập tin sau đó chạy chương trình MaSh với thông số thích hợp, kết quả do MaSh trả về cũng được truy xuất qua tập tin output.</p>

<p>Sau quá trình đo lường, ta được một kết quả không mong đợi, thời gian trung bình cho mỗi lần giao tiếp với MaSh khoảng 0.1 giây. Một con số tưởng chừng khá nhỏ, nhưng khi đem so sánh với thời gian cho mỗi lần đơn giản hóa biểu thức, thời gian cũng xấp xỉ 0.1 giây. Vậy nên nếu ta áp dụng bộ lọc MaSh vào hệ thống hiện tại, thời gian đơn giản hóa của biểu thức sẽ bằng tổng thời gian bộ lọc hoạt động cộng với thời gian cho quá trình đơn giản hóa. Kết quả là không những ta không tăng tốc được hệ thống mà thời gian đơn giản hóa còn tăng lên.</p>

<p>Sau khi xem xét lại về kĩ thuật, ta nhận thấy những lỗi lầm chính sau:</p>

<ul>
<li>MaSh viết bằng Python, một ngôn ngữ chậm [cite]</li>
<li>Mỗi lần tương tác với MaSH ta phải khởi tạo một tiến trình mới. Phí tổn cho việc này quá lớn</li>
<li>Việc tương tác với MaSh thông qua hệ thống file cho đầu vào và đầu ra cũng góp phần làm chậm quá trình tương tác.</li>
</ul>

<p>Nhận thấy những sai lầm trên, phiên bản mới của bộ lọc được hiện thực lại hoàn toàn bằng ngôn ngữ Java, hệ thống tương tác với bộ lọc thông qua việc gọi phương thức. </p>

<p>Kết quả đo lường cho bộ lọc mới cho thấy thời gian trung bình cho mỗi lần tương tác với bộ lọc khoảng <em>0.00002 giây</em>, tức là nhanh hơn <em>5000 lần</em> so với bộ lọc ban đầu.</p>

<p>Kinh nghiệm này nói lên một điều rằng, <em>không chỉ độ phức tạp của thuật toán mà những yếu tố kỹ thuật cũng đóng vai trò cực kỳ quan trọng đối với hiệu năng của hệ thống.</em></p>

<h3 class="wmd-title" id="profiling-with-refactoring-and-caching">Profiling with refactoring and caching</h3>

<p>Profiling là quá trình ghi nhận và biểu diễn lại thông tin về việc sử dụng tài nguyên của hệ thống. Profiling đóng vai trò nền tảng trong quy trình cải thiện hiệu năng hệ thống.</p>

<p>Dưới đây là mô tả cho quy trình cải thiện hiệu năng</p>

<pre class="prettyprint prettyprinted" style=""><code><span class="str">/-------------------------------------------------------\   
|                                                       |
|  /</span><span class="pun">-------------</span><span class="pln">\        </span><span class="pun">+------------------------+</span><span class="pln">    </span><span class="pun">|</span><span class="pln">
\-</span><span class="pun">&gt;|</span><span class="pln">  </span><span class="typ">Profiling</span><span class="pln">  </span><span class="pun">|------&gt;</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> </span><span class="typ">Improve</span><span class="pln"> important parts</span><span class="pun">|----/</span><span class="pln">
   \-</span><span class="pun">------------/</span><span class="pln">        </span><span class="pun">+------------------------+</span></code></pre>

<p>Quá trình liên tục không ngường trong việc cải thiện hiệu năng của hệ thống. Quy trình này không những được áp dụng cho riêng hệ thống phần mềm mà được áp dụng cho mọi hệ thống kĩ thuật nói chung.</p>

<p>Ở đây ta sẽ trình bày hai kỹ thuật thông dụng được dùng trong quá trình cải thiện hiệu năng của hệ thống phần mềm.</p>

<h4 class="wmd-title" id="refactoring">Refactoring</h4>

<p>Quá trình refactoring loại bỏ ra hệ thống những phần thừa không cần thiết, cải thiện những phần yếu kém. điều này không những làm cho bức tranh về hệ thống trở nên rõ ràng mà bên cạnh đó hiệu năng cũng được cải thiện.</p>

<p>Luận văn đã sử dụng profiling kết hợp với refactoring để phát hiện và loại bỏ những phần gây chậm cho hệ thống mà lại không cần thiết. Đồng thời những phần gây chậm cho hệ thống đa phần các trường hợp sẽ được <em>tái hiện thực</em> với chủ định về cải thiện hiệu năng.</p>

<p>Có thể kể ra một vài ví dụ trong việc refactoring trong quá trình làm luận văn. </p>

<p>Minh họa đầu tiên là về quá trình đơn giản hóa, bản hiện thực ban đầu sử dụng Z3 solver cho quá trình kiểm tra các điều kiện của rewrite rules. Sau khi nhận thấy Z3 solver là nhân tố chính gây chậm cho hệ thống, bản hiện thực mới đã loại bỏ Z3 solver khỏi quá trình đơn giản hóa.</p>

<p>Một ví dụ khác cũng về việc sử dụng Z3 solver nhưng ở trong bối cảnh khác, như được trình bày ở hình [ref-to] sau khi được đơn giản hóa, biểu thức cần chứng minh sẽ được đưa vào solver để chứng minh. Sau khi profiling nhận thấy việc tạo mới quá nhiều solver gây một ảnh hưởng lớn tới hiệu năng của hệ thống. Qua quá trình refactoring, hệ thống bây giờ chỉ tạo một lượng cố định các solver và tái sử dụng các solver này khi cần dùng đến.</p>

<h4 class="wmd-title" id="caching">Caching</h4>

<p>Cũng tương tự giải pháp tái sử dụng trong ví dụ ở phần <em>Refactoring</em>, caching là kĩ thuật lưu giữ những</p>

<h3 class="wmd-title" id="parallel-verification">Parallel verification</h3>

<p>Song song hóa trở thành xu hướng tất yếu của thị trường cứng bộ xữ lý. Khi hàng rào năng lượng không cho phép tiếp tục tăng xung nhịp của bộ xữ lý [cite], thì lựa chọn đa lõi trở thành bắt buộc để có được sức mạnh tính toán cao hơn. [giọng văn khủng bố, please đơn giản, giản dị]</p>

<p>Sự chuyển dịch của lĩnh vực phần cứng là động lực dẫn tới sự thay đổi trong thiết kế hệ thống phần mềm. Các hệ thống phần mềm muốn sử dụng được tối đa tài nguyên phần cứng bắt đầu được thiết kế trền nền tảng song song. </p>

<p>Việc song song hóa được thể hiện ở nhiều mức độ khác nhau. Chúng ta có thể liệt kê vài mức độ như sau:</p>

<ul>
<li>Song song về threads, một ứng dụng dùng một process với nhiều thread để tận dụng tài nguyên CPU.</li>
<li>Song song về process, ứng dụng bây giờ là tập hợp của các process chạy song song trên cùng một máy tính.</li>
<li>Song song về máy tính, ứng dụng là tập tập hợp của các process chạy song song trên nhiều máy tính, tương tác với nhau thông qua giao thức mạng.</li>
</ul>

<p>Với ý tưởng thực hiện việc song song hóa các quá trình chứng minh những tính chất riêng biệt. Nói cách khác, những tính chất riêng biệt có thể được chứng minh song song độc lập với nhau.</p>

<p>Dựa trên ý tưởng trên, luận văn đã hiện thực song song hóa ở mức độ đầu tiên, song song về thread. Các một thread pool khởi tạo một lượng cố định các thread (tùy thuộc với số lượng nhân của hệ thống phần cứng), các threads này sẽ được lần lượt giao nhiệm vụ khi cần đến.</p>

<p>Một yêu cầu quan trọng trong việc song song hóa threads là các threads phải giảm đến mức tối thiểu việc sử dụng tài nguyên chung, vì điều này dễ gây ra tình trạng race condition [footnote]</p>

<p>Một điểm lợi trong việc sử dụng ngôn ngữ Scala là thư viện chuẩn của ngôn ngữ này hỗ trợ tốt song song hóa. Việc song song hóa được thực hiện đơn giản và hiệu quả.</p>

<p>Trong phiên bản ban đầu ta có</p>

<pre class="prettyprint prettyprinted" style=""><code><span class="pln">val lst </span><span class="pun">=</span><span class="pln"> generationVCs</span><span class="pun">()</span><span class="pln"> </span><span class="com">/* getting list of verfication condtions */</span><span class="pln">

lst</span><span class="pun">.</span><span class="kwd">foreach</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> x </span><span class="pun">=&gt;</span><span class="pln">  try_to_prove</span><span class="pun">(</span><span class="pln">x</span><span class="pun">)</span><span class="pln"> </span><span class="pun">}</span><span class="pln">   </span><span class="com">/* We're step-by-step trying to prove VCs */</span></code></pre>

<p>Phiên bản song song có được với điều chỉnh nhỏ:</p>

<pre class="prettyprint prettyprinted" style=""><code><span class="pln">val lst_old </span><span class="pun">=</span><span class="pln"> generationVCs</span><span class="pun">()</span><span class="pln"> </span><span class="com">/* getting list of verfication condtions */</span><span class="pln">
val lst </span><span class="pun">=</span><span class="pln"> lst_old</span><span class="pun">.</span><span class="pln">par         </span><span class="com">/* This function generates a parallel list */</span><span class="pln">

lst</span><span class="pun">.</span><span class="kwd">foreach</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> x </span><span class="pun">=&gt;</span><span class="pln">  try_to_prove</span><span class="pun">(</span><span class="pln">x</span><span class="pun">)</span><span class="pln"> </span><span class="pun">}</span><span class="pln">   </span><span class="com">/* We're step-by-step trying to prove VCs */</span></code></pre>

<p>Chỉ với việc gọi <code>par</code> method, chúng ta sinh ra một parallel list, khi đó mọi phương thức của danh sách mới này sẽ được tự động thực hiện song song. Trong trường hợp của chúng ta, phương thức <code>foreach</code> sẽ được thực hiện song song với mỗi phần tử thuộc danh sách.</p>

<p>Một điểm mạnh khác của ngôn ngữ Scala, Scala là một ngôn ngữ lập trình hàm, nên đa phần mã của hệ thống Leon được viết theo phong cách thuần hàm. Nói cách khác, đa phần các hàm của hệ thống Leon không có hiệu ứng lề, giảm đến mức tối đa race condition.</p>

<p>Tuy nhiên, Scala cũng hỗ trợ mô hình lập trình hướng đối tượng, và cho phép sử dụng biến.</p>

<p>Ở đây ta sẽ đi qua một trường hợp race condition xuất hiện khi chuyển đổi hệ thống Leon từ tuần tự sang song song.</p>

<p>Bên cạnh đó một số kĩ thuật cũng được áp dụng nhằm tránh khỏi race condition cũng được mô tả.</p>

<h4 class="wmd-title" id="một-trường-hợp-race-condition">Một trường hợp race condition</h4>

<p>Hiện thực của hệ thống hệ tại sử dụng một đối tượng sau:</p>

<pre class="prettyprint prettyprinted" style=""><code><span class="pln">  </span><span class="kwd">private</span><span class="pln"> </span><span class="kwd">object</span><span class="pln"> </span><span class="typ">UniqueCounter</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">private</span><span class="pln"> </span><span class="kwd">var</span><span class="pln"> globalId </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pln">
    </span><span class="kwd">private</span><span class="pln"> </span><span class="kwd">var</span><span class="pln"> nameIds </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Map</span><span class="pun">[</span><span class="typ">String</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">]().</span><span class="pln">withDefaultValue</span><span class="pun">(-</span><span class="lit">1</span><span class="pun">)</span><span class="pln">

    </span><span class="kwd">def</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">(</span><span class="pln">name</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      nameIds </span><span class="pun">+=</span><span class="pln"> name </span><span class="pun">-&gt;</span><span class="pln"> </span><span class="pun">(</span><span class="lit">1</span><span class="pun">+</span><span class="pln">nameIds</span><span class="pun">(</span><span class="pln">name</span><span class="pun">))</span><span class="pln">
      nameIds</span><span class="pun">(</span><span class="pln">name</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">def</span><span class="pln"> nextGlobal </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      globalId </span><span class="pun">+=</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
      globalId
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span></code></pre>

<h2 class="wmd-title" id="experiment-and-measurement">Experiment and Measurement</h2>

<h2 class="wmd-title" id="conclusion">Conclusion</h2>

<h2 class="wmd-title" id="references">References</h2>

<h2 class="wmd-title" id="appendix-a-how-did-i-work">Appendix A - How did I work</h2>

<h2 class="wmd-title" id="appendix-b-regression-test-and-continuous-integration">Appendix B - Regression test and Continuous integration</h2>

<h2 class="wmd-title" id="appendix-c-leon-system">Appendix C - Leon system</h2>

<h2 class="wmd-title" id="appendix-d-screen-shots">Appendix D - Screen shots</h2>

<ul>
<li>PURPOSE
<ul><li>Luận văn này trở thành kiểu mẫu cho các luận văn kĩ sư về sau.</li>
<li>Người đọc chỉ cần kiến thức cơ bản về Khoa học máy tính để có thể đọc hiểu hoàn toàn nội dùng của luận văn (self-contain)</li>
<li>Ngôn ngữ đơn giản, gần gũi, dễ hiểu, dí dỏm</li>
<li>Giọng văn riêng của tác giả, truyền tải kinh nghiệm có được trong quá trình làm luận văn</li>
<li>Chi tiết đến mức tối đa có thể, tuy tốn nhiều thời gian nhưng kết quả mang lại sẽ tuyệt vời</li>
<li>Như một quyển sách giáo khoa thường thức!</li>
<li>Truyền tải nhiều thông tin thú vị về lịch sử nhân vật quan trọng trong ngành</li>
<li>Làm cho người đọc hứng thú đọc, xem luận văn như một câu chuyện kể li lỳ và hấp dẫn</li>
<li>Đưa người đọc đến thế giới tuyệt vời của logic học :-)</li></ul></li>
</ul>

<div class="footnotes"><hr><ol><li id="fn:formalmethods">de dam bao chuong trinh may tinh lam viec hoan toan dung so voi dac ta cua no ta khong the su dung phuong phep testing truyen thong - <a href="http://c2.com/cgi/wiki?TestsCantProveTheAbsenceOfBugs">http://c2.com/cgi/wiki?TestsCantProveTheAbsenceOfBugs</a> <a href="#fnref:formalmethods" title="Return to article" class="reversefootnote">↩</a></li><li id="fn:hg">Hilbert va Godel duoc coi la 2 trong 4 nha logic vi dai nhat tung song <a href="#fnref:hg" title="Return to article" class="reversefootnote">↩</a></li><li id="fn:dana">Nguoi dat giai Turing cho nhung dong gop ve Automata theory
[fermat]: dinh ly duoc chung minh boi nha toan hoc ~ten trong khoang thoi gian 10 nam lam viec doc lap <a href="#fnref:dana" title="Return to article" class="reversefootnote">↩</a></li><li id="fn:proofasiss">la nhung chuong trinh may tinh ho tro nguoi dung trong chung minh <a href="#fnref:proofasiss" title="Return to article" class="reversefootnote">↩</a></li></ol></div>
  
</section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
