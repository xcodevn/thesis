<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Thesis by xcodevn</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      
    <div class="wrapper">

      <section>
<h1 class="wmd-title" id="interactive-verification-and-speed-up-techniques">INTERACTIVE VERIFICATION AND SPEED UP TECHNIQUES</h1>

<ul>
<li>PURPOSE
<ul><li>Luận văn này trở thành kiểu mẫu cho các luận văn kĩ sư về sau.</li>
<li>Người đọc chỉ cần kiến thức cơ bản về Khoa học máy tính để có thể đọc hiểu hoàn toàn nội dùng của luận văn (self-contain)</li>
<li>Ngôn ngữ đơn giản, gần gũi, dễ hiểu, dí dỏm</li>
<li>Giọng văn riêng của tác giả, truyền tải kinh nghiệm có được trong quá trình làm luận văn</li>
<li>Chi tiết đến mức tối đa có thể, tuy tốn nhiều thời gian nhưng kết quả mang lại sẽ rất tuyệt vời</li>
<li>Như một quyển sách giáo khoa thường thức!</li>
<li>Truyền tải nhiều thông tin thú vị về lịch sử nhân vật quan trọng trong ngành</li>
<li>Làm cho người đọc hứng thú đọc, xem luận văn như một câu chuyện kể li lỳ và hấp dẫn</li>
<li>Đưa người đọc đến thế giới tuyệt vời của logic học :-)</li></ul></li>
</ul>

<h2 class="wmd-title" id="abstract">Abstract</h2>

<blockquote>
  <p>Beware of bugs in the above code; I have only proved it correct, not tried it – Donald Knuth</p>
  
  <p>Cẩn thận với lỗi trong đoạn mã trên; tôi chỉ mới chứng minh nó đúng, chứ chưa hề chạy thử nó – Donald Knuth</p>
</blockquote>

<p>Chứng minh tính đúng đắn của một chương trình may tinh dung formal methods <a href="#fn:formalmethods" id="fnref:formalmethods" title="See footnote" class="footnote">1</a> mang lại sự đảm bảo cao nhất cho các chương trình yêu cầu tính chính xác cao (ví dụ chương trình lái tàu vũ trụ, lái máy bay, lái tàu điện ngầm, …) Đây hoàn toàn không phải là công việc dễ dàng, hiện nay chương trình máy tính vẫn chưa thể tự động hoàn toàn trong việc chứng minh các chương trình phức tạp trong thực tế [cite-source]. Một hệ quả là phải có sự tương tác giữa người với máy tính trong quá trình chứng minh các đoạn mã phức tạp.</p>

<p>Luận văn này hiện thực ý tưởng về <em>interactive verification</em>, là sự tương tác
giữa người và chương trình chứng minh nhằm chứng minh tính đúng đắn của các
chương trình phức tạp.</p>

<blockquote>
  <p>Với việc sử dụng <em>rewriting term</em>, hệ thống Leon [footnote] đã có thể tạo ra &gt; sự tương tác hai chiều với người dùng. [Remove]</p>
</blockquote>

<p>Bên cạnh đó, luận văn còn đề cập tới khía cạnh tốc độ của quá trình chứng minh, 
một loạt các kỹ thuật tăng tốc đã được áp dụng nhằm cải tiến tốc độ của hệ thống. Có thể kể đến ba nổ lực chính: 
(1) áp dụng bộ lọc sử dụng tri thức của hệ thống và học máy để lọc bỏ những
phần thừa trong quá trình tính toán, 
(2) kĩ thuật profiling được áp dụng nhằm phát hiện những mắc xích chiếm lượng
lớn thời gian tính toán, từ đó mà tập trung cải thiện tốc độ của các phần này,
(3) thực hiện song song hóa quá trình chứng minh.</p>

<p>Dựa vào những kĩ thuật trên, luận văn đã đạt được một sự cải thiện rõ rệt về tốc
độ của hệ thống, tốc độ chứng minh đã tăng xấp xĩ <strong>30 lần</strong> so với bản hiện
thực ban đầu.</p>

<p>Bên cạnh những kết quả đạt được trên, bản thân tác giả cũng gặt hái được nhiều
kinh nghiệm quý báu trong quá trình làm luận văn, nhất là kinh nghiệm trong quy
trình hiện thực hệ thống và trong việc đảm bảo chất lượng, tính ổn định của hệ
thống. Thiết nghĩ đây là những kinh nghiệm quan trọng đối với một người kĩ sư.</p>

<hr>

<h2 class="wmd-title" id="acknowledgement">Acknowledgement</h2>

<p>Tác giả gửi lời cảm ơn chân thành đến phó giáo sư tiến sĩ Quản Thành Thơ, phó
giáo sư tiến sĩ Viktor Kuncak đã có những góp ý quan trọng và định hướng cho
luận văn này.</p>

<p>Tác giả gửi lời cảm ơn của mình đến anh Hoàng Lê Nghĩa Đức, là người đã theo
sát, và hỗ trợ tác giả trong thời gian làm luận văn.</p>

<p>Và trên tất cả, luận văn này dành cho gia đình của tác giả, nhất là người mẹ đã luôn
chăm sóc và dõi theo tác giả.</p>

<p>Gửi lời tưởng nhớ đến thầy Dương Công Vinh, người đã dắt tác giả đi những bước đi
dau tien trên con đường đến với ngành <em>khoa học máy tính</em>.</p>

<hr>

<h2 class="wmd-title" id="đóng-góp-của-luận-văn">Đóng góp của luận văn</h2>

<p>Luận văn đã mở rộng khả năng của hệ thống hiện tại, cho phép hỗ trợ
chứng minh tương tác, sử dụng các bổ để, từ đó cho phép chứng minh tự động
những tính chất mà trước kia phải dựa vào người sử dụng.</p>

<p>Luận văn cũng nên lên ý tưởng về <em>interactive learning</em>, trong đó cho phép giải
thuật học máy có thể học từ chính quá trình sử dụng hệ thống của người dùng.</p>

<p>Với những nổ lực trong việc cải thiện tốc độ, hệ thống đã có những cải
thiện rõ rệt về tốc độ, góp phần cải thiện đáng kể thời gian tương tác với người
dùng. [lủng củng]</p>

<p>Việc sử dụng bộ lọc áp dụng học máy không chỉ có tác dụng tăng tốc cho riêng hệ
thống, mà bộ lọc còn có thể được sử dụng trong các trường hợp tương tự, có thể kể đến như là bộ lọc đảm nhận vai trò tiền xữ lý trong đề tài "Name it please" của nghiên cứu sinh [Tên anh í]</p>

<p>Một đóng góp nhỏ và thuần túy về kỹ thuật, người khiến bản thân tác giả rất hài lòng đó là trong thời gian làm việc với hệ thống, tác giả đã phát hiện và sửa được một lỗi tồn tại trong một thời gian dài bên trong nhân của hệ thống.</p>

<p>Bên cạnh đó, trong thời gian rãnh rỗi của mình, tác giả cũng đã thiết kế một
giao diện mới cho hệ thống trên nền web. Tuy khối lượng công việc nhỏ, nhưng cũng có thể coi đây là một thói quen có ích trong việc sử dụng thời gian rãnh rỗi.</p>

<hr>

<h2 class="wmd-title" id="table-of-contain">Table of contain</h2>

<h2 class="wmd-title" id="introduction">Introduction</h2>

<p>Logic học là lĩnh vực nghiên cứu về sự suy luận đúng đắn. Ngày nay, logic học là nền tảng của mọi lĩnh vực toán học hiện đại. Logic được nhiều nhà hiền triết nghiên cứu từ thời cổ đại, có thể kể đến logic tam đoạn luận [footnote] của Aristote. Logic học thực sự trở thành nền tảng của toán học từ cuối thế kỉ XIX đầu thế kỉ XX với nổ lực thống nhất toán học trên cùng một nền tảng logic học của Hilbert, được biết đến với tên gọi <em>chương trình Hilbert</em>. Để rồi đến năm 1931 khi  Kurt Gödel đập tan chương trình Hilbert với việc chứng minh hai định lý <em>bất hoàn chỉnh</em> [lúa quá] nổi tiếng [cite-footnote]<a href="#fn:hg" id="fnref:hg" title="See footnote" class="footnote">2</a>. Tất nhiên chương trình Hilbert không phải là vô dụng, bộ mặt của toán học đã thay đổi hoàn toàn, logic giờ đã đóng vai trò là nền tảng trong mọi nhánh của toán học. Đưới nền tảng logic vững chắc, mọi định lý toán học sẽ luôn là những chân lý trường tồn cùng thời gian.</p>

<p>Năm 1969, Dana S. SCoot<a href="#fn:dana" id="fnref:dana" title="See footnote" class="footnote">3</a> viết một bài báo đánh dấu sự ra đời của <em>Logic cho những hàm khả tính</em> (Logic of Computable Functions - LCF). Bài báo này mở ra một nhánh nghiên cứu mới, là sự kết hợp giữa logic học và giải tích lambda. Trên nền tảng đó, các nhà nghiên cứu tại đại học Edinburgh dưới sự dẫn dắt của Robin Milner [footnote: Robin Milner đạt giải Turing năm 1991 cho những đóng góp với ngành Khoa học máy tính] LCF, một trong những <em>interactive automated theorem prover</em> đầu tiên. Bên cạnh đó là sự ra đời của ngôn ngữ lập trình hàm ML, ngon ngu này anh hưởng lớn tới các ngôn ngữ lập trình hàm hiện đại như Ocamal, Haskell, hay Scala.</p>

<p>Điều thú vụ của lịch sử là bài báo này chưa từng được công bố rộng rãi cho đến tận năm 1993, lý do cho việc này là tác giả của bài báo nhận thấy sự không cần thiết của việc xuất bản bài báo :)
Có lẽ đây là bài báo không được xuất bản có ảnh hưởng lớn nhất trong lịch sử của ngành Khoa học máy tính.</p>

<p>Những <em>proof asisstance</em><a href="#fn:proofasiss" id="fnref:proofasiss" title="See footnote" class="footnote">4</a> có thể chứng minh (dựa trên tương tác với người dùng) những định lý lớn của toán học, có thể kể đến định lý bất hoàn hảo của Godel, định lý Fermat lớn[^fermat].</p>

<p>Bên cạnh đó là những ứng dụng thực tiễn, có thể kể đến hardware verification[cite], chứng minh tính đúng đắn của một hệ điều hành hoàn chỉnh [cite L4OS], trình biên dịch [cite], JavaCard[cite]</p>

<p>Leon là một chương trình chứng minh tự động được phát triển bởi nhóm nghiên cứu
LARA tại đại học EPFL, Thụy Sĩ.
Điểm mạnh của Leon là cho phép người lập trình dùng chính ngôn ngữ Scala cho
việc đặc tả những tính chất của chương trình Scala.
Leon có thể phát hiện ra các <em>phản ví dụ</em> trong trường hợp có sự sai khác giữa đặc tả và hiện thực.</p>

<p>Về nguyên tắc, Leon thực hiện việc chứng minh trên môt ngôn ngữ gọi là PureScala.
Ngôn ngữ này là một tập con của ngôn ngữ Scala, chỉ hỗ trợ các hàm không có hiệu ứng lề (thuần hàm) với yêu cầu các hàm này phải là hàm bậc nhất (không nhận một hàm khác như là tham số, cũng như không trả về một hàm) và chỉ hỗ trợ các kiểu dữ liệu đơn giản (số nguyên, kiểu dữ liệu trừu tượng, tập hợp, tuples)</p>

<p>Leon hoạt động dựa trên ý tưởng đơn giản là <em>unrolling</em>. Để chứng minh một
biểu thức thỏa một tính chất nào đó, với những hàm không đệ quy trong biểu thức, ta có thể thực hiện đơn giản bởi việc thay lời gọi hàm bằng thân của hàm này đã được thay các biến bởi các tham số truyền theo. 
Đối với các hàm gọi chính nó (hàm đệ quy) Leon cũng thực hiện tương tự, nhưng
kết quả cho mỗi lần <em>unrolling</em>, ta chỉ được một phiên bản xấp xỉ với hàm đệ qui.
Dựa vào việc <em>xấp xĩ dưới</em> (một xấp xĩ mà nếu hàm này trả về là sai với đặc tả
thì hàm đệ quy cũng sai với đặc tả), và <em>xấp xĩ trên</em> (một xấp xĩ mà nếu hàm
này trả về là đúng với đặc tả thì hàm đệ quy cũng đúng với đặc tả) ta có thể
thoát ra khỏi quá trình Unrolling vô tận và vẫn đảm bảo tính đúng đắn của chứng
minh (hoặc phản ví dụ). 
Nói một cách ngắn gọn , de chứng minh một tính chất của một biểu thức ta thực
hiện chứng minh trên các xấp xĩ trên và xấp xĩ dưới của biểu thức này.</p>

<p>Tuy nhiên, hệ thống Leon hiện tại hỗ trợ rất kém trong việc chứng minh một tính
chất của chương trình bằng cách sử dụng các bổ đề kèm theo.
Một sự thật rằng đa phần các chứng minh luôn cần những bồ đề kèm theo. 
Có thể giải thích duoc việc này nếu coi Leon là một hệ thống chứng minh diễn dịch, nói cách khác, thông thường Leon sẽ không thể thực hiện việc chứng minh qui nạp nếu không có sử tương tác với người dùng.
Chính các bổ đề sẽ lấp đầy mắc xích trống, các bổ đề sẽ nhận nhiệm vụ chứng minh qui nạp.</p>

<p>Luận văn đưa ra ý tưởng sử dụng rewriting term, để don gian hoa biểu thức cần
chứng minh trước khi đưa cho solver bên dưới.</p>

<p>Quá trình <em>simplify</em> một biểu thức là quá trình biển đổi biểu thức về một dạng
tương tương nhưng đơn giản hơn thong qua cac <em>rewriting rules</em>.
Bằng việc sử dụng các <em>rewriting rules</em> có dạng <code>if COND then LHS = RHS</code> ta có
thể thay vế trái <code>LHS</code> bằng vế phải <code>RHS</code> nếu <code>COND</code> được thỏa.
Quá trình xem ra đơn giản này là một trong những cấu thành chính va phuc tap
nhat của các <em>Interactive proof assistance.</em></p>

<p>Bằng việc chuyển đổi các bổ đề, định nghĩa hàm, giả thuyết quy nạp trở thành các <em>rewriting rules</em> ta có thể chứng minh một cách tự động những tính chất mà trước kia phải làm bằng tay.</p>

<p>Một trong những chú trọng của luận văn này là cải thiện thời gian chứng minh của Leon tới mới tối đa có thể. Có thể kể đến ba nỗ lực chính để đạt mục tiêu trên.</p>

<p>Thứ nhất là việc sử dụng một bộ lọc nhằm lọc ra các <em>rewrite rules</em> không cần
thiết cho quá trình chứng minh.
Thực nghiệm cho thấy một số lượng rất ít các rules là cần thiết cho quá trình
chứng minh.
Để cải thiện tốc độ ta mong muốn lọc ra nhưng rules cần thiết và loại bỏ những
rules thừa.
Tất nhiên là hiệu năng mang lại phải lớn hơn phí tổn trong khi bộ lọc hoạt động.
Bằng việc sử dụng thuật toán học máy Naive-Bayes, luận văn này hiện thực một bộ
lọc có khả năng học được những tri thức từ quá trình chứng minh trước đó, hoặc
những tri thức do người dùng đưa vào để cải thiện chất lượng của bộ lọc.</p>

<p>Thứ hai là việc sử dụng kĩ thuật profiling, đây là một quy trình kép kín,
profiling cho phép phát hiện những bộ phận trong hệ thống chiếm phần lớn tài
nguyên máy tính (CPU hay RAM) từ đó chúng ta tập trung cải tiến những phần quan
trọng này.
Quy trình này được lập lại, và mỗi lần lặp tốc độ của hệ thống lại được cải thiện.</p>

<p>Nỗ lực thứ ba để đẩy tốc độ của hệ thống và có lẽ là nhân tố quan trọng nhất đó
là thực hiện song song hóa hệ thống hiện tại.
Ý tưởng đơn giản là ta có thể chứng minh các tính chất của chương trình một cách song song, độc lập với nhau.
Chỉ với nỗ lực này, kết quả đạt được là hệ thống có thể mở rộng tới mức tối đa.</p>

<p>Ở phần cuối của luận văn, tác giả cũng đề cập tới qui trình hiện thực toàn bộ
luận văn sử dụng công cụ quản lý dự án Github cũng như git cho chức năng quản lý mã nguồn, mà theo ý kiến riêng của tác giả là điều này nằm ngoài những kiến thức đã được dạy ở giảng đường.
Bên cạnh đó là kinh nghiệm của tác giả trong việc đảm bảo chất lượng cũng như
tính ổn định của hệ thống thông qua việc thực hiện <em>regression testing</em> và <em>tích hợp liên tục</em> (CI - english please!)</p>

<p>Phần tiếp theo sẽ đi vào chi tiết về interactive verification, các kĩ thuật tăng tốc được áp dụng.</p>

<h2 class="wmd-title" id="interactive-verification">Interactive verification</h2>

<p>Như đã lập luận ở trên, quá trình chứng minh những chương trình phức tạp là quá trình tương tác giữa người sử dụng và chương tình máy tính. Ở đây ta sẽ mô tả một kịch bản cho quá trình tương tác này.</p>

<h3 class="wmd-title" id="kịch-bản">Kịch bản</h3>

<p>Câu chuyện bắt đầu khi nhân vật chính của chúng ta, Văn Hòa, muốn chứng minh tính đúng đắn của thuật toán sắp xếp mới do chính tay Văn Hòa nghĩ ra. Văn Hòa bắt đầu mô tả tính chất mong muốn của thuật toán, đầu vào theo như hắn nghĩ chắc chắn sẽ là một danh sách các số nguyên, và đầu ra của thuật toán sẽ là một hoán vị của danh sách ban đầu sao cho các số nguyên trong danh sách có thứ tự không giảm.</p>

<p>Vậy là Văn Hòa đã đặc tả được tính chất mong muốn cho thuật toán của mình, một thuật toán sắp xếp tăng dần. Nhân vật chính hứng thú nhấp chuột vào nút <em>Chứng minh</em> trên cửa sổ phần mềm vô danh [Microsoft Word ;)]. Một lát sau, có lẽ là 10 phút sau, phần mềm trả về một thông báo không hề được mong đợi “Không thể chứng minh”. Chỉ vỏn vẹn một thông báo như vậy. </p>

<p>Văn Hòa bắt đầu trâm ngâm suy nghĩ ”ừ thì đồng ý là chương trình này phức tạp nên không thể chứng minh được nhưng …” Nhân vật chính ”Ồ!” lên trong khoảng không, dường như anh đã nhận ra một điều gì đó tinh tế. Thầm nghĩ trong đầu “nếu không thế chứng minh được thì ít nhất cũng phải chứng minh tới đâu đó, cho dù chưa tới đích”.</p>

<p>Tiếp tục với những suy tư trong đầu mình, cuối cùng bước tranh cũng dần hiện rõ trong đầu Văn Hòa. “Phải chăng có một cơ chế nào đó, biến mục tiêu cần chứng minh ban đầu, thành các mục tiêu con đơn giản hơn, lúc này người dùng có thể tập trung vào việc chứng minh các mục tiêu con”</p>

<p>Màn đêm bắt đầu buông xuống, xung quanh phố phường chìm dần vào trong đêm tối, chỉ có căn phòng của nhân vật chính là con sáng điện. Trong căn phòng đó có một người đang miệt mài với những suy nghĩ trong đầu mình.</p>

<p>Những suy tư tưởng chừng như chỉ xuất hiện trong đầu Văn Hòa, nhân vật chính của chúng ta, cũng chính là suy tư của những người đã viết nên các <em>interactive ATP</em> nổi tiếng như LCF, HOL, Isabelle. Khái niệm <em>cơ chế nào đó</em> trong đầu Văn Hòa chính là proof tactic, chiến lược chứng minh. Một chiến lược chứng minh có thể được xem như một cổ máy có đầu vào là mục tiêu cần chứng minh, đầu ra của cổ máy này chính là một danh sách các mục tiêu con, tất nhiên là đơn giản hơn mục tiêu ban đầu.</p>

<p>Có thể kể đến hai chiến lược dễ hình dung và có lẽ là hữu hiệu nhất</p>

<ul>
<li><p>Chiến lực Quy nạp: chiến lược này biến mục tiêu cần chứng minh thành hai mục tiêu con, mục tiêu thứ nhất chứng minh trường hợp cơ bản của quá trình quy nạp, mục tiêu con thứ hai là chứng minh trường hợp tới.</p></li>
<li><p>Chiến lược đơn giản hóa (simplify): chiến lược này tìm cách biến đổi mục tiêu ban đầu (gọi là <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-1-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-1" style="width: 1.301em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.977em; height: 0px; font-size: 132%;"><span style="position: absolute; clip: rect(1.572em 1000.003em 2.492em -0.43em); top: -2.162em; left: 0.003em;"><span class="mrow" id="MathJax-Span-2"><span class="msubsup" id="MathJax-Span-3"><span style="display: inline-block; position: relative; width: 0.923em; height: 0px;"><span style="position: absolute; clip: rect(2.005em 1000.003em 2.762em -0.43em); top: -2.595em; left: 0.003em;"><span class="mi" id="MathJax-Span-4" style="font-family: MathJax_Math; font-style: italic;">e</span><span style="display: inline-block; width: 0px; height: 2.6em;"></span></span><span style="position: absolute; top: -2.216em; left: 0.49em;"><span class="mn" id="MathJax-Span-5" style="font-size: 70.7%; font-family: MathJax_Main;">1</span><span style="display: inline-block; width: 0px; height: 2.384em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.167em;"></span></span></span><span style="border-left-width: 0.004em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.932em; vertical-align: -0.282em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-1">e_1</script>) trở thành mục tiêu mới (gọi là <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-2-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-6" style="width: 1.301em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.977em; height: 0px; font-size: 132%;"><span style="position: absolute; clip: rect(1.572em 1000.003em 2.492em -0.43em); top: -2.162em; left: 0.003em;"><span class="mrow" id="MathJax-Span-7"><span class="msubsup" id="MathJax-Span-8"><span style="display: inline-block; position: relative; width: 0.923em; height: 0px;"><span style="position: absolute; clip: rect(2.005em 1000.003em 2.762em -0.43em); top: -2.595em; left: 0.003em;"><span class="mi" id="MathJax-Span-9" style="font-family: MathJax_Math; font-style: italic;">e</span><span style="display: inline-block; width: 0px; height: 2.6em;"></span></span><span style="position: absolute; top: -2.216em; left: 0.49em;"><span class="mn" id="MathJax-Span-10" style="font-size: 70.7%; font-family: MathJax_Main;">2</span><span style="display: inline-block; width: 0px; height: 2.384em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.167em;"></span></span></span><span style="border-left-width: 0.004em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.932em; vertical-align: -0.282em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-2">e_2</script>), tương tương với mục tiêu ban đầu. Rõ ràng ta có phương trình <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-3-Frame" role="textbox" aria-readonly="true" style=""><nobr><span class="math" id="MathJax-Span-11" style="width: 4.223em; display: inline-block;"><span style="display: inline-block; position: relative; width: 3.195em; height: 0px; font-size: 132%;"><span style="position: absolute; clip: rect(2.221em 1000.003em 3.141em -0.43em); top: -2.811em; left: 0.003em;"><span class="mrow" id="MathJax-Span-12"><span class="msubsup" id="MathJax-Span-13"><span style="display: inline-block; position: relative; width: 0.923em; height: 0px;"><span style="position: absolute; clip: rect(2.005em 1000.003em 2.762em -0.43em); top: -2.595em; left: 0.003em;"><span class="mi" id="MathJax-Span-14" style="font-family: MathJax_Math; font-style: italic;">e</span><span style="display: inline-block; width: 0px; height: 2.6em;"></span></span><span style="position: absolute; top: -2.216em; left: 0.49em;"><span class="mn" id="MathJax-Span-15" style="font-size: 70.7%; font-family: MathJax_Main;">1</span><span style="display: inline-block; width: 0px; height: 2.384em;"></span></span></span></span><span class="mo" id="MathJax-Span-16" style="font-family: MathJax_Main; padding-left: 0.273em;">=</span><span class="msubsup" id="MathJax-Span-17" style="padding-left: 0.273em;"><span style="display: inline-block; position: relative; width: 0.923em; height: 0px;"><span style="position: absolute; clip: rect(2.005em 1000.003em 2.762em -0.43em); top: -2.595em; left: 0.003em;"><span class="mi" id="MathJax-Span-18" style="font-family: MathJax_Math; font-style: italic;">e</span><span style="display: inline-block; width: 0px; height: 2.6em;"></span></span><span style="position: absolute; top: -2.216em; left: 0.49em;"><span class="mn" id="MathJax-Span-19" style="font-size: 70.7%; font-family: MathJax_Main;">2</span><span style="display: inline-block; width: 0px; height: 2.384em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.817em;"></span></span></span><span style="border-left-width: 0.004em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.932em; vertical-align: -0.282em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-3">e_1 = e_2</script>. Một cách tổng quát hóa, quá trình đơn giản hóa là quá trình áp dụng các luật có dạng 
<code>COND ==&gt; LHS = RHS</code>, tức là nếu điều kiện <code>COND</code> được thỏa thì ta sẽ thay thế biểu thức <code>LHS</code> bằng biểu thức <code>RHS</code>.</p></li>
</ul>

<p>Trong phần tiếp theo, ta sẽ đi vào chi tiết của chiến lược đơn giản hóa. Đây cũng chính là cấu thành quan trọng nhất đối với <em>interactive verification</em>.</p>

<h3 class="wmd-title" id="simlification">Simlification</h3>

<h2 class="wmd-title" id="advanced-speed-up-techniques">Advanced speed up techniques</h2>

<h2 class="wmd-title" id="experiment-and-measurement">Experiment and Measurement</h2>

<h2 class="wmd-title" id="conclusion">Conclusion</h2>

<h2 class="wmd-title" id="references">References</h2>

<h2 class="wmd-title" id="appendix-a-how-did-i-work">Appendix A - How did I work</h2>

<h2 class="wmd-title" id="appendix-b-regression-test-and-continuous-integration">Appendix B - Regression test and Continuous integration</h2>

<h2 class="wmd-title" id="appendix-c-leon-system">Appendix C - Leon system</h2>

<h2 class="wmd-title" id="appendix-d-screen-shots">Appendix D - Screen shots</h2>

<div class="footnotes"><hr><ol><li id="fn:formalmethods">de dam bao chuong trinh may tinh lam viec hoan toan dung so voi dac ta cua no ta khong the su dung phuong phep testing truyen thong - <a href="http://c2.com/cgi/wiki?TestsCantProveTheAbsenceOfBugs">http://c2.com/cgi/wiki?TestsCantProveTheAbsenceOfBugs</a> <a href="#fnref:formalmethods" title="Return to article" class="reversefootnote">↩</a></li><li id="fn:hg">Hilbert va Godel duoc coi la 2 trong 4 nha logic vi dai nhat tung song <a href="#fnref:hg" title="Return to article" class="reversefootnote">↩</a></li><li id="fn:dana">Nguoi dat giai Turing cho nhung dong gop ve Automata theory
[fermat]: dinh ly duoc chung minh boi nha toan hoc ~ten trong khoang thoi gian 10 nam lam viec doc lap <a href="#fnref:dana" title="Return to article" class="reversefootnote">↩</a></li><li id="fn:proofasiss">la nhung chuong trinh may tinh ho tro nguoi dung trong chung minh <a href="#fnref:proofasiss" title="Return to article" class="reversefootnote">↩</a></li></ol></div>
      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
